<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Soul Hunters 3D</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; font-family: 'Consolas', monospace; user-select: none; }
        #game-stage { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; outline: none; }

        /* HUD */
        #ui-layer { position: absolute; top: 10px; width: 100%; pointer-events: none; z-index: 10; display: flex; justify-content: center; align-items: flex-start; }
        .top-bar { display: flex; gap: 20px; align-items: center; pointer-events: auto; }
        .score-board {
            background: rgba(0,0,0,0.7); color: white; padding: 8px 25px; border-radius: 5px;
            font-size: 20px; border: 1px solid #555; text-align: center; min-width: 200px;
        }
        .blue { color: #44aaff; } .red { color: #ff4444; }
        .ctrl-group { display: flex; gap: 5px; }
        .ctrl-btn {
            background: #333; color: #ccc; border: 1px solid #555; padding: 5px 12px;
            cursor: pointer; font-size: 14px; border-radius: 4px; font-weight: bold; transition: all 0.1s;
        }
        .ctrl-btn:hover { background: #444; color: white; }
        .ctrl-btn.active { background: #006600; color: #0f0; border-color: #0f0; }
        .ctrl-btn.paused { background: #666600; color: #ff0; border-color: #ff0; }

        #hero-dock {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 20; pointer-events: auto;
        }
        .hero-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 3px solid #555;
            background: #333; color: white; font-weight: bold; font-size: 16px;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            cursor: pointer; transition: 0.2s; position: relative; overflow: hidden;
        }
        .hero-btn.ready { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; background: #444; }
        .hero-btn:active { transform: scale(0.95); }
        .hero-btn.dead { filter: grayscale(100%); opacity: 0.5; cursor: not-allowed; }
        .hero-txt { z-index: 2; position: relative; text-shadow: 0 0 3px black; }
        .mp-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(255, 215, 0, 0.5); transition: height 0.2s; pointer-events: none; z-index: 1; }

        #settlement {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background:rgba(0,0,0,0.85); display:none; flex-direction:column;
            justify-content:center; align-items:center; z-index:100; color:white;
        }
        #settlement.show { display:flex; }
        h1 { font-size: 60px; margin-bottom: 20px; }
        button { padding: 10px 30px; font-size: 20px; cursor: pointer; background: #ffd700; border: none; font-weight: bold; border-radius: 5px; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; z-index: 99; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

<div id="game-stage">
    <div id="loading">Loading 3D Engine...</div>
    <div id="ui-layer">
        <div class="top-bar">
            <div class="ctrl-group">
                <button class="ctrl-btn" id="pause-btn" onclick="togglePause()">‚è∏Ô∏è ÊöÇÂÅú</button>
                <button class="ctrl-btn" id="speed-btn" onclick="toggleSpeed()">‚è© 1.0x</button>
            </div>
            <div class="score-board">
                <span class="blue">BLUE: <span id="hp-blue">...</span></span>
                VS
                <span class="red">RED: <span id="hp-red">...</span></span>
                <br>
                <span style="font-size:14px; color:#aaa">‰∏ã‰∏ÄÊ≥¢: <span id="wave-timer">--</span>s</span>
            </div>
            <div class="ctrl-group">
                <button class="ctrl-btn" id="auto-btn" onclick="toggleAutoUlt()">ü§ñ Ëá™Âä®Â§ßÊãõ</button>
<!--                <button class="ctrl-btn" id="debug-btn" onclick="toggleDebug()">üî≥ Debug</button>-->
            </div>
        </div>
    </div>
    <div id="hero-dock"></div>
    <div id="settlement">
        <h1 id="win-title">VICTORY</h1>
        <button onclick="location.reload()">RESTART</button>
    </div>
</div>

<script>
    /**
     * ÂºïÊìé V79: ÊµÅÁïÖÁªïË°å‰ºòÂåñ (Fluid Steering)
     * 1. Âº±ÂåñÂàπËΩ¶Ôºö‰∏çÂÜçÊÄ•ÂÅúÔºåËÄåÊòØÂ∞ùËØïÂáèÈÄüÂπ∂‰æßÊªë„ÄÇ
     * 2. Âº∫ÂåñÁªïË°åÔºöÂ§ßÂπÖÂ¢ûÂä†‰æßÂêëÈÅøËÆ©ÂäõÔºåËÆ©Âçï‰Ωç‚ÄúÊµÅ‚ÄùËøáÈöúÁ¢ç„ÄÇ
     * 3. Áâ©ÁêÜÂ±ÇÔºö‰øùÊåÅ Unit-Unit Á°¨Á¢∞ÊíûÔºåÈò≤Ê≠¢Á©øÊ®°„ÄÇ
     */

// ================= ÂÖ®Â±ÄÂèòÈáè =================
    const SPAWN_INTERVAL = 15.0;
    const RESPAWN_TIME = 20.0;
    const COLORS = { BLUE: '#44aaff', RED: '#ff4444', MINION_BLUE: '#88ccff', MINION_RED: '#ff8888', TOWER: '#ffffff' };

    let entities = [];
    let buildings = [];
    let projectiles = [];
    let particles = [];
    let waveTimer = SPAWN_INTERVAL;
    let isGameOver = false;
    let lastTime = 0;

    let DEBUG_MODE = false;
    let IS_PAUSED = false;
    let TIME_SCALE = 1.0;
    let PLAYER_AUTO_ULT = false;

    let MAP = { BLUE_BASE: {}, RED_BASE: {}, LANES: {} };

    let scene, camera, renderer, groundMesh;
    let width = window.innerWidth;
    let height = window.innerHeight;

    function getThreeColor(hexStr) { return new THREE.Color(hexStr); }
    const COLORS_3D = { BLUE: getThreeColor(COLORS.BLUE), RED: getThreeColor(COLORS.RED) };

    function init3D() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a1a1a);
        let maxDim = Math.max(width, height);
        camera = new THREE.PerspectiveCamera(35, width / height, 10, 10000);
        let centerX = width / 2;
        let centerZ = height / 2;
        let scale = Math.max(width, height) / 700;
        camera.position.set(centerX - 200 * scale, 450 * scale, centerZ + 600 * scale);
        camera.lookAt(centerX, 0, centerZ);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(width, height);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('game-stage').appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xaaaaaa, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(centerX - 500, 1500, centerZ + 500);
        dirLight.target.position.set(centerX, 0, centerZ);
        scene.add(dirLight.target);
        dirLight.castShadow = true;
        const shadowD = Math.max(width, height) * 1.5;
        dirLight.shadow.camera.left = -shadowD; dirLight.shadow.camera.right = shadowD;
        dirLight.shadow.camera.top = shadowD; dirLight.shadow.camera.bottom = -shadowD;
        dirLight.shadow.mapSize.width = 4096; dirLight.shadow.mapSize.height = 4096;
        scene.add(dirLight);

        const groundGeo = new THREE.PlaneGeometry(width * 2.5, height * 2.5);
        groundGeo.rotateX(-Math.PI / 2);
        groundGeo.translate(width / 2, 0, height / 2);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x222222, side: THREE.DoubleSide });
        groundMesh = new THREE.Mesh(groundGeo, groundMat);
        groundMesh.receiveShadow = true;
        scene.add(groundMesh);

        drawLanes();
        document.getElementById('loading').style.display = 'none';
    }

    function drawLanes() {
        const material = new THREE.LineBasicMaterial({ color: 0x444444, linewidth: 2 });
        const yHeight = 5;
        const createLine = (pts) => {
            const geo = new THREE.BufferGeometry().setFromPoints(pts.map(p => new THREE.Vector3(p.x, yHeight, p.y)));
            scene.add(new THREE.Line(geo, material));
        };
        if (MAP.BLUE_BASE && MAP.RED_BASE) {
            createLine([MAP.BLUE_BASE, MAP.LANES.TOP_LEFT, MAP.RED_BASE]);
            createLine([MAP.BLUE_BASE, MAP.LANES.BOT_RIGHT, MAP.RED_BASE]);
            createLine([MAP.BLUE_BASE, MAP.RED_BASE]);
        }
    }

    function toggleDebug() { DEBUG_MODE = !DEBUG_MODE; document.getElementById('debug-btn').classList.toggle('active'); }
    function togglePause() { IS_PAUSED = !IS_PAUSED; const btn = document.getElementById('pause-btn'); btn.classList.toggle('paused'); btn.innerText = IS_PAUSED ? "‚ñ∂Ô∏è ÁªßÁª≠" : "‚è∏Ô∏è ÊöÇÂÅú"; }
    function toggleSpeed() { TIME_SCALE = TIME_SCALE === 1.0 ? 2.0 : 1.0; const btn = document.getElementById('speed-btn'); btn.classList.toggle('active'); btn.innerText = TIME_SCALE === 2.0 ? "‚è© 2.0x" : "‚è© 1.0x"; }
    function toggleAutoUlt() { PLAYER_AUTO_ULT = !PLAYER_AUTO_ULT; document.getElementById('auto-btn').classList.toggle('active'); }

    function getSpawnPoint(team, lane) {
        let base = team === 'BLUE' ? MAP.BLUE_BASE : MAP.RED_BASE;
        let x = base.x, y = base.y, offset = 50;
        if (team === 'BLUE') {
            if (lane === 'TOP') y -= offset; else if (lane === 'BOT') x += offset; else { x += offset*0.7; y -= offset*0.7; }
        } else {
            if (lane === 'TOP') x -= offset; else if (lane === 'BOT') y += offset; else { x -= offset*0.7; y += offset*0.7; }
        }
        x += (Math.random() * 10 - 5); y += (Math.random() * 10 - 5);
        return { x, y };
    }

    // Áâ©ÁêÜÂºïÊìéÔºö‰øùÊåÅÁ°¨Á¢∞Êíû‰ª•Èò≤Ê≠¢ÈáçÂè†
    function resolveCollisions() {
        for(let iter=0; iter<3; iter++) {
            // 1. Unit vs Unit (Hard Collision)
            for (let i = 0; i < entities.length; i++) {
                let u1 = entities[i];
                if (u1.dead || u1.state === 'RESPAWNING') continue;
                if (u1.x < u1.physicsRadius) u1.x = u1.physicsRadius; if (u1.x > width - u1.physicsRadius) u1.x = width - u1.physicsRadius;
                if (u1.y < u1.physicsRadius) u1.y = u1.physicsRadius; if (u1.y > height - u1.physicsRadius) u1.y = height - u1.physicsRadius;

                for (let j = i + 1; j < entities.length; j++) {
                    let u2 = entities[j];
                    if (u2.dead || u2.state === 'RESPAWNING') continue;

                    let dx = u1.x - u2.x;
                    let dy = u1.y - u2.y;
                    let distSq = dx*dx + dy*dy;
                    let minSep = u1.physicsRadius + u2.physicsRadius;

                    if (distSq < minSep * minSep && distSq > 0.001) {
                        let dist = Math.sqrt(distSq);
                        let overlap = minSep - dist;
                        let push = overlap * 0.5;
                        let nx = dx / dist;
                        let ny = dy / dist;
                        u1.x += nx * push; u1.y += ny * push;
                        u2.x -= nx * push; u2.y -= ny * push;
                    }
                }
            }

            // 2. Unit vs Building
            entities.forEach(u => {
                if (u.dead || u.state === 'RESPAWNING') return;
                buildings.forEach(b => {
                    if (b.dead) return;
                    let halfW = b.collider.w / 2; let halfH = b.collider.h / 2;
                    let minX = b.x - halfW; let maxX = b.x + halfW;
                    let minY = b.y - halfH; let maxY = b.y + halfH;
                    let cx = Math.max(minX, Math.min(u.x, maxX));
                    let cy = Math.max(minY, Math.min(u.y, maxY));
                    let dx = u.x - cx; let dy = u.y - cy;
                    let distSq = dx*dx + dy*dy;
                    if (distSq < u.physicsRadius * u.physicsRadius) {
                        let dist = Math.sqrt(distSq);
                        if (dist > 0) {
                            let overlap = u.physicsRadius - dist;
                            u.x += (dx / dist) * overlap;
                            u.y += (dy / dist) * overlap;
                        } else {
                            let dLeft = u.x - minX; let dRight = maxX - u.x; let dTop = u.y - minY; let dBottom = maxY - u.y;
                            let minD = Math.min(dLeft, dRight, dTop, dBottom);
                            const buffer = 0.5;
                            if (minD === dLeft) u.x = minX - u.physicsRadius - buffer;
                            else if (minD === dRight) u.x = maxX + u.physicsRadius + buffer;
                            else if (minD === dTop) u.y = minY - u.physicsRadius - buffer;
                            else u.y = maxY + u.physicsRadius + buffer;
                        }
                    }
                });
            });
        }
    }

    function createVFX(type, x, y, color) {
        if (type === 'NORMAL') {
            for(let i=0; i<3; i++) particles.push(new Particle(x, y, '#cccccc', 'SMALL'));
        } else if (type === 'CRIT') {
            for(let i=0; i<15; i++) {
                let c = Math.random() > 0.5 ? '#ffd700' : '#ff4500';
                particles.push(new Particle(x, y, c, 'BURST'));
            }
        } else if (type === 'ULT') {
            particles.push(new ShockwaveRing(x, y, color));
            for(let i=0; i<20; i++) particles.push(new Particle(x, y, color, 'RISE'));
        }
    }

    function findSmartTarget(me, range) {
        let candidates = [...entities, ...buildings].filter(e => e.team !== me.team && !e.dead && e.state !== 'RESPAWNING');

        let inRange = candidates.filter(e => {
            let dist = Math.hypot(e.x - me.x, e.y - me.y);
            let targetRadius = e.physicsRadius || (e.collider ? e.collider.w/2 : 20);
            return dist <= range + targetRadius;
        });

        if (inRange.length === 0) return null;
        let units = inRange.filter(e => e instanceof Unit);
        let structs = inRange.filter(e => e instanceof Building);
        if (units.length > 0) return units.sort((a,b) => Math.hypot(a.x-me.x, a.y-me.y) - Math.hypot(b.x-me.x, b.y-me.y))[0];
        return structs.sort((a,b) => Math.hypot(a.x-me.x, a.y-me.y) - Math.hypot(b.x-me.x, b.y-me.y))[0];
    }

    // ================= ÂÆû‰ΩìÁ±ª =================

    class Entity {
        constructor(x, y, team, radius) {
            this.x = x; this.y = y; this.team = team;
            this.radius = radius;
            this.physicsRadius = radius;
            this.hp = 100; this.maxHp = 100; this.dead = false;
            this.mesh = null; this.hpBarGroup = null; this.hpBarFill = null;
            this.debugGroup = null;
            this.steeringForce = { x: 0, y: 0 };
        }

        sync3D() {
            if (!this.mesh) return;
            let visible = !this.dead && this.state !== 'RESPAWNING';
            this.mesh.visible = visible;
            if(this.hpBarGroup) this.hpBarGroup.visible = visible;
            if(this.debugGroup) {
                this.debugGroup.visible = visible && DEBUG_MODE;
                if(visible) this.debugGroup.position.set(this.x, 2, this.y);
            }
            if (visible) {
                this.mesh.position.set(this.x, this.mesh.userData.yOffset || 0, this.y);
                if (this.hpBarGroup) {
                    this.hpBarGroup.position.set(this.x, (this.mesh.userData.height || 20) + 15, this.y);
                    let pct = Math.max(0, this.hp / this.maxHp);
                    this.hpBarFill.scale.x = pct;
                    this.hpBarFill.visible = pct > 0;
                    this.hpBarGroup.rotation.x = -Math.PI / 4;
                    this.hpBarGroup.lookAt(camera.position);
                }
            }
        }

        createHpBar(w) {
            this.hpBarGroup = new THREE.Group();
            const bgGeo = new THREE.PlaneGeometry(w, 6);
            const bgMat = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
            this.hpBarGroup.add(new THREE.Mesh(bgGeo, bgMat));
            const fillGeo = new THREE.PlaneGeometry(w, 4);
            fillGeo.translate(w/2, 0, 0);
            let color = this.team === 'BLUE' ? 0x00ff00 : 0xff3333;
            this.hpBarFill = new THREE.Mesh(fillGeo, new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide }));
            this.hpBarFill.position.x = -w/2;
            this.hpBarFill.position.z = 0.5;
            this.hpBarGroup.add(this.hpBarFill);
            scene.add(this.hpBarGroup);
        }

        createDebugVisuals(height, attackRange) {
            this.debugGroup = new THREE.Group();
            let geo, color = 0x00ff00;
            if (this.collider && this.collider.type === 'BOX') {
                geo = new THREE.BoxGeometry(this.collider.w, height, this.collider.h);
                color = 0x00ffff;
            } else {
                geo = new THREE.CylinderGeometry(this.physicsRadius, this.physicsRadius, height, 16);
            }
            const edges = new THREE.EdgesGeometry(geo);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color }));
            line.position.y = height / 2;
            this.debugGroup.add(line);

            if (attackRange > 0) {
                const curve = new THREE.EllipseCurve(0, 0, attackRange, attackRange, 0, 2 * Math.PI);
                const pts = curve.getPoints(64);
                const rngGeo = new THREE.BufferGeometry().setFromPoints(pts);
                const rngLine = new THREE.Line(rngGeo, new THREE.LineBasicMaterial({ color: 0xffff00 }));
                rngLine.rotation.x = -Math.PI / 2; rngLine.position.y = 1;
                this.debugGroup.add(rngLine);
            }
            scene.add(this.debugGroup);
        }

        takeDamage(amount, isCrit) {
            if(this.dead) return;
            this.hp -= amount;
            if (this.type === 'HERO' || isCrit) createVFX(isCrit ? 'CRIT' : 'NORMAL', this.x, this.y, '#fff');
            if(this.hp <= 0) { this.hp = 0; this.die(); }
        }

        dispose() {
            if (this.mesh) { scene.remove(this.mesh); this.mesh = null; }
            if (this.hpBarGroup) { scene.remove(this.hpBarGroup); this.hpBarGroup = null; }
            if (this.debugGroup) { scene.remove(this.debugGroup); this.debugGroup = null; }
        }

        die() {
            this.dead = true;
            createVFX('CRIT', this.x, this.y, this.team === 'BLUE' ? COLORS.BLUE : COLORS.RED);
            if (this.type !== 'HERO') this.dispose();
        }
    }

    class Building extends Entity {
        constructor(x, y, team, type, lane) {
            super(x, y, team, type === 'BASE' ? 35 : 20);
            this.type = type; this.lane = lane;
            this.maxHp = type === 'BASE' ? 4000 : 1500; this.hp = this.maxHp;
            this.range = 160; this.atkDmg = 50; this.atkTimer = 0;

            this.visualSize = type === 'BASE' ? 60 : 40;
            this.visualHeight = type === 'BASE' ? 40 : 80;
            this.collider = { type: 'BOX', w: this.visualSize * 1.3, h: this.visualSize * 1.3 };
            this.physicsRadius = Math.sqrt(Math.pow(this.collider.w/2, 2) + Math.pow(this.collider.h/2, 2));

            this.createMesh();
        }
        createMesh() {
            const color = this.team === 'BLUE' ? COLORS_3D.BLUE : COLORS_3D.RED;
            const geo = new THREE.BoxGeometry(this.visualSize, this.visualHeight, this.visualSize);
            const mat = new THREE.MeshPhongMaterial({ color: color });
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.userData.yOffset = this.visualHeight / 2;
            this.mesh.userData.height = this.visualHeight;
            this.mesh.castShadow = true; this.mesh.receiveShadow = true;
            scene.add(this.mesh);
            this.createHpBar(this.visualSize);
            this.createDebugVisuals(this.visualHeight, this.range);
            this.sync3D();
        }
        update(dt) {
            if (this.dead) return;
            this.atkTimer += dt;
            if (this.atkTimer > 1.2) {
                let target = findSmartTarget(this, this.range);
                if (target) {
                    projectiles.push(new Projectile(this.x, this.y, target, this.atkDmg, '#ffff00'));
                    this.atkTimer = 0;
                }
            }
            this.sync3D();
        }
        draw(ctx) {}
        die() { super.die(); this.dispose(); if (this.type === 'BASE') checkGameOver(this.team); }
    }

    class Unit extends Entity {
        constructor(id, x, y, team, type, lane) {
            super(x, y, team, type === 'HERO' ? 16 : 10);
            this.physicsRadius = this.radius * 2.0;
            this.id = id; this.type = type; this.lane = lane;
            if (type === 'HERO') { this.maxHp = 1200; this.atk = 100; this.speed = 60; this.range = 130; this.mp = 0; this.maxMp = 100; }
            else { this.maxHp = 300; this.atk = 20; this.speed = 40; this.range = 45; }
            this.hp = this.maxHp;
            this.collider = { type: 'CIRCLE', radius: this.physicsRadius };

            this.state = 'MOVE'; this.respawnTimer = 0; this.target = null; this.atkTimer = 0;
            this.waypoints = this.getWaypoints(team, lane); this.wpIndex = 0; this.uiBtn = null;
            this.facingAngle = 0;
            this.createMesh();
        }
        createMesh() {
            const color = this.team === 'BLUE' ? COLORS_3D.BLUE : COLORS_3D.RED;
            const r = this.radius;
            const h = this.type === 'HERO' ? 40 : 25;
            const geo = new THREE.CylinderGeometry(r, r, h, 16);
            const mat = new THREE.MeshPhongMaterial({ color: color });
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.userData.yOffset = h / 2;
            this.mesh.userData.height = h;
            this.mesh.castShadow = true; this.mesh.receiveShadow = true;

            const noseGeo = new THREE.BoxGeometry(r/2, r/2, r);
            const noseMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(0, h/4, r);
            this.mesh.add(nose);

            if (this.type === 'HERO') {
                const ringGeo = new THREE.TorusGeometry(r+2, 1, 16, 32);
                ringGeo.rotateX(Math.PI/2);
                const ringMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
                this.ringMesh = new THREE.Mesh(ringGeo, ringMat);
                this.ringMesh.position.y = -h/2 + 1;
                this.mesh.add(this.ringMesh);
            }

            scene.add(this.mesh);
            this.createHpBar(r*2);
            this.createDebugVisuals(h, this.range);
            this.sync3D();
        }

        getWaypoints(team, lane) {
            let path = []; let enemyBase = team === 'BLUE' ? MAP.RED_BASE : MAP.BLUE_BASE; let off = (Math.random() - 0.5) * 40;
            if (lane === 'MID') { path.push({x: enemyBase.x, y: enemyBase.y}); }
            else if (lane === 'TOP') { path.push({x: MAP.LANES.TOP_LEFT.x + off, y: MAP.LANES.TOP_LEFT.y + off}); path.push({x: enemyBase.x, y: enemyBase.y}); }
            else if (lane === 'BOT') { path.push({x: MAP.LANES.BOT_RIGHT.x + off, y: MAP.LANES.BOT_RIGHT.y + off}); path.push({x: enemyBase.x, y: enemyBase.y}); }
            return path;
        }

        update(dt) {
            if (this.state === 'RESPAWNING') { this.respawnTimer -= dt; if (this.respawnTimer <= 0) this.respawn(); this.sync3D(); return; }
            if (this.dead) { this.sync3D(); return; }

            if (this.type === 'HERO' && this.mp < 100) this.mp += dt * 8;
            let shouldAutoUlt = !this.isPlayerControlled() || PLAYER_AUTO_ULT;
            if (this.type === 'HERO' && shouldAutoUlt && this.mp >= 100 && this.target) { if(Math.random() < 0.05) this.castUltimate(); }

            if (this.type === 'HERO') {
                let myBase = buildings.find(b => b.type === 'BASE' && b.team === this.team);
                let enemiesAtBase = entities.some(e => e.team !== this.team && !e.dead && Math.hypot(e.x - myBase.x, e.y - myBase.y) < 400);
                if (enemiesAtBase) {
                    let targetAtBase = findSmartTarget(myBase, 400);
                    if (targetAtBase) { this.target = targetAtBase; }
                    else { this.target = null; this.moveTowards(myBase.x, myBase.y, dt); this.sync3D(); return; }
                }
            }

            if (!this.target || this.target.dead || this.target.state === 'RESPAWNING') {
                let searchRange = 280; if (this.type === 'MINION') searchRange = 180;
                else if (this.wpIndex === 0 && this.lane !== 'MID') searchRange = 200;
                this.target = findSmartTarget(this, searchRange);

                if (this.type === 'HERO' && !this.target) {
                    let enemyTowerInLane = buildings.find(b => b.team !== this.team && b.type === 'TOWER' && b.lane === this.lane && !b.dead);
                    if (!enemyTowerInLane) {
                        let roamTarget = findSmartTarget(this, 2000);
                        if(roamTarget) this.target = roamTarget;
                    }
                }
            }

            if (this.target) {
                let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                let targetRad = this.target.physicsRadius || 20;
                let range = this.range + targetRad + this.physicsRadius * 0.5;

                if (this.type === 'MINION' && dist > 250) { this.target = null; this.state = 'MOVE'; return; }

                if (dist <= range) {
                    this.atkTimer += dt;
                    this.facingAngle = Math.atan2(this.target.y - this.y, this.target.x - this.x);
                    if (this.atkTimer > 1.5) {
                        let isCrit = Math.random() < 0.2; let dmg = this.atk * (isCrit ? 2.0 : 1.0);
                        if (this.range > 50) projectiles.push(new Projectile(this.x, this.y, this.target, dmg, '#fff'));
                        else this.target.takeDamage(dmg, isCrit);
                        this.atkTimer = 0; if(this.type === 'HERO') this.mp = Math.min(100, this.mp + 15);
                    }
                    // ÂÅúÊ≠¢ÁßªÂä®Ôºå‰∏çÂÅö moveTowards
                } else {
                    this.moveTowards(this.target.x, this.target.y, dt);
                }
            } else {
                if (this.lane !== 'MID' && this.wpIndex === 0 && this.waypoints.length > 1) {
                    let wp0 = this.waypoints[0];
                    let passed = false;
                    if (this.team === 'BLUE' && this.lane === 'TOP' && this.y < wp0.y) passed = true;
                    if (this.team === 'BLUE' && this.lane === 'BOT' && this.x > wp0.x) passed = true;
                    if (this.team === 'RED'  && this.lane === 'TOP' && this.x < wp0.x) passed = true;
                    if (this.team === 'RED'  && this.lane === 'BOT' && this.y > wp0.y) passed = true;
                    if (passed) this.wpIndex = 1;
                }
                if (this.wpIndex < this.waypoints.length) {
                    let wp = this.waypoints[this.wpIndex];
                    if (Math.hypot(wp.x - this.x, wp.y - this.y) < 20) this.wpIndex++; else this.moveTowards(wp.x, wp.y, dt);
                }
            }
            this.sync3D();
        }

        // ‰ºòÂåñÂêéÁöÑÁßªÂä®ÈÄªËæëÔºöÊµÅ‰ΩìÁªïË°å + ‰æßÂêëÊªëÊ≠•
        moveTowards(tx, ty, dt) {
            let dx = tx - this.x;
            let dy = ty - this.y;
            let dist = Math.hypot(dx, dy);
            if(dist === 0) return;

            // 1. ÂéüÂßãÊÑèÂõæÔºöÁõ¥Â•îÁõÆÊ†á
            let moveX = (dx / dist);
            let moveY = (dy / dist);

            // 2. ÈÅøËÆ©Âäõ (Steering)
            let steerX = 0, steerY = 0;
            let speedMod = 1.0; // Â∞ΩÈáè‰øùÊåÅÂÖ®ÈÄüÔºåÂáèÂ∞ëÊÄ•ÂàπËΩ¶

            entities.forEach(other => {
                if (other === this || other.dead || other.state === 'RESPAWNING') return;

                let d = Math.hypot(this.x - other.x, this.y - other.y);
                // Âà§ÂÆöËåÉÂõ¥ÔºöÊØîÁâ©ÁêÜÂçäÂæÑÁ®çÂ§ß‰∏ÄÁÇπÂç≥ÂèØÔºå‰∏çÁî®Â§™Â§ßÔºåÂê¶ÂàôÂèçÂ∫îËøáÊøÄ
                let detectionRange = (this.physicsRadius + other.physicsRadius) * 1.5;

                if (d < detectionRange && d > 0) {
                    // ÊåáÂêëÂØπÊñπÁöÑÂêëÈáèÔºàÂΩí‰∏ÄÂåñÔºâ
                    let toOtherX = (other.x - this.x) / d;
                    let toOtherY = (other.y - this.y) / d;

                    // Êñ•ÂäõÂº∫Â∫¶ÔºöË∂äËøëË∂äÂ§ß
                    let force = (detectionRange - d) / detectionRange;

                    // ËÆ°ÁÆóÂΩìÂâçÁßªÂä®ÊñπÂêë‰∏éÂØπÊñπÊñπ‰ΩçÁöÑÂ§πËßí (Dot Product)
                    let dot = moveX * toOtherX + moveY * toOtherY;

                    if (dot > 0.6) {
                        // „ÄêÊÉÖÂÜµAÔºöÊ≠£ÂâçÊñπÊã•Â†µ„Äë -> ‰∫ßÁîüÂº∫ÁÉàÁöÑ‰æßÂêëÊªëÊ≠•Âäõ (Tangent Force)
                        // ËøôÊòØ‰∏Ä‰∏™ÁÆÄÂçï‰∏îÊûÅÊúâÊïàÁöÑÁªïË°åÊäÄÂ∑ßÔºöÊ†πÊçÆÁõ∏ÂØπ‰ΩçÁΩÆËÆ°ÁÆóÂàáÁ∫øÊñπÂêë
                        // Â¶ÇÊûúÂØπÊñπÁï•ÂæÆÂú®Â∑¶ÔºåÊàëÂ∞±ÂæÄÂè≥ÂàáÔºõÁï•ÂæÆÂú®Âè≥ÔºåÊàëÂ∞±ÂæÄÂ∑¶Âàá

                        // Âü∫Á°ÄÊéíÊñ• (‰∏çË¶ÅÊíû‰∏äÂéª)
                        steerX -= toOtherX * force * 5.0;
                        steerY -= toOtherY * force * 5.0;

                        // ÂàáÂêëÊªëÂä® (ÂÖ≥ÈîÆ‰ºòÂåñÔºö‰∏éÂÖ∂ÂÅú‰∏ãÔºå‰∏çÂ¶ÇÊ®™Áßª)
                        // ÂêëÈáè (-y, x) ÊòØÈÄÜÊó∂Èíà90Â∫¶Ôºå(y, -x) ÊòØÈ°∫Êó∂Èíà90Â∫¶
                        // Âà©Áî®Âèâ‰πòÂéüÁêÜÂÜ≥ÂÆöÂæÄÂì™ËæπÊªëÊõ¥È°∫
                        let cross = moveX * toOtherY - moveY * toOtherX;
                        if (cross > 0) {
                            // ÂØπÊñπÂú®Â∑¶‰æßÔºåÂæÄÂè≥Êªë
                            steerX += toOtherY * force * 3.0;
                            steerY += -toOtherX * force * 3.0;
                        } else {
                            // ÂØπÊñπÂú®Âè≥‰æßÔºåÂæÄÂ∑¶Êªë
                            steerX += -toOtherY * force * 3.0;
                            steerY += toOtherX * force * 3.0;
                        }

                        // Âè™ÊúâË¥¥ÂæóÊûÅËøëÊó∂ÊâçËΩªÂæÆÂáèÈÄüÔºå‰øùÁïôÂä®Èáè
                        if (d < (this.physicsRadius + other.physicsRadius) * 1.05) {
                            speedMod = Math.min(speedMod, 0.5);
                        }
                    }
                    else if (dot > -0.5) {
                        // „ÄêÊÉÖÂÜµBÔºö‰æßÊñπÊàñÊñúÂêéÊñπ„Äë -> ËΩªÂæÆÊéíÊñ•Ôºå‰øùÊåÅÈòüÂΩ¢Èó¥Ë∑ù
                        steerX -= toOtherX * force * 1.5;
                        steerY -= toOtherY * force * 1.5;
                    }
                }
            });

            // 3. ÂºïÂÖ•ÂæÆÈáèÈöèÊú∫Âô™ÁÇπ (Jitter)
            // ËøôÊòØÈò≤Ê≠¢‚ÄúÊ≠ªÈîÅ‚ÄùÁöÑÁ•ûÂô®ÔºåÊâìÁ†¥ÂÆåÁæéÁöÑÊï∞Â≠¶ÂØπÁß∞ÊÄßÔºåËÆ©‰∏§‰∏™Èù¢ÂØπÈù¢ÁöÑÂçï‰ΩçËÉΩÈîôÂºÄ
            steerX += (Math.random() - 0.5) * 0.2;
            steerY += (Math.random() - 0.5) * 0.2;

            // 4. Ê∑∑ÂêàÂäõÂú∫
            let finalX = moveX + steerX;
            let finalY = moveY + steerY;

            // ÂΩí‰∏ÄÂåñÂπ∂Â∫îÁî®
            let finalLen = Math.hypot(finalX, finalY);
            if (finalLen > 0.01) {
                finalX /= finalLen;
                finalY /= finalLen;

                this.facingAngle = Math.atan2(finalY, finalX);
                this.x += finalX * this.speed * dt * speedMod;
                this.y += finalY * this.speed * dt * speedMod;
            }
        }

        sync3D() {
            super.sync3D();
            if (this.mesh && !this.dead) {
                this.mesh.rotation.y = -this.facingAngle + Math.PI/2;
                if (this.ringMesh) this.ringMesh.visible = (this.mp >= 100);
            }
        }

        castUltimate() {
            if (this.mp < 100 || this.dead) return;
            this.mp = 0;
            let color = this.team === 'BLUE' ? COLORS.BLUE : COLORS.RED;
            createVFX('ULT', this.x, this.y, color);
            let targets = findAllTargets(this, 250);
            targets.forEach(t => t.takeDamage(200, true));
        }
        isPlayerControlled() { return this.team === 'BLUE'; }
        die() { if (this.type === 'HERO') { this.state = 'RESPAWNING'; this.respawnTimer = RESPAWN_TIME; this.dead = true; if(this.uiBtn) this.uiBtn.classList.add('dead'); } else { super.die(); } }
        respawn() {
            this.dead = false; this.hp = this.maxHp; this.mp = 0; this.state = 'IDLE'; this.lane = getBestLane(this.team);
            let spawnPos = getSpawnPoint(this.team, this.lane); this.x = spawnPos.x; this.y = spawnPos.y; this.target = null; this.waypoints = this.getWaypoints(this.team, this.lane); this.wpIndex = 0;
            createVFX('ULT', this.x, this.y, '#fff');
            if(this.uiBtn) { this.uiBtn.classList.remove('dead'); let txtSpan = this.uiBtn.querySelector('.hero-txt'); if(txtSpan) txtSpan.innerText = this.lane[0]; }
            this.sync3D();
        }
        draw(ctx) {}
    }

    function findNearestTarget(me, range) { return findSmartTarget(me, range); } // Fallback

    function findAllTargets(me, range) { return [...entities, ...buildings].filter(e => e.team !== me.team && !e.dead && e.state !== 'RESPAWNING' && Math.hypot(e.x - me.x, e.y - me.y) <= range); }
    function getBestLane(myTeam) { let counts = { 'TOP': 0, 'MID': 0, 'BOT': 0 }; entities.forEach(e => { if (!e.dead && e.state !== 'RESPAWNING' && e.lane) counts[e.lane]++; }); let best = 'MID'; if (counts.TOP > counts.MID && counts.TOP > counts.BOT) best = 'TOP'; else if (counts.BOT > counts.MID && counts.BOT > counts.TOP) best = 'BOT'; return best; }
    function checkGameOver(loserTeam) { if (isGameOver) return; isGameOver = true; let title = document.getElementById('win-title'); document.getElementById('settlement').classList.add('show'); if (loserTeam === 'RED') { title.innerText = "BLUE WINS!"; title.style.color = COLORS.BLUE; } else { title.innerText = "RED WINS!"; title.style.color = COLORS.RED; } }

    class Projectile {
        constructor(x, y, target, dmg, color) {
            this.x = x; this.y = y; this.target = target; this.dmg = dmg; this.color = color; this.speed = 400; this.hit = false;
            this.createMesh();
        }
        createMesh() {
            const geo = new THREE.SphereGeometry(4, 8, 8);
            const mat = new THREE.MeshBasicMaterial({ color: getThreeColor(this.color) });
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.set(this.x, 20, this.y);
            scene.add(this.mesh);
        }
        update(dt) {
            if (this.hit) { if(this.mesh) this.dispose(); return; }
            if (this.target.dead) { this.hit = true; this.dispose(); return; }
            let dx = this.target.x - this.x; let dy = this.target.y - this.y; let dist = Math.hypot(dx, dy);
            if (dist < 15) { this.hit = true; this.target.takeDamage(this.dmg, false); this.dispose(); }
            else { let angle = Math.atan2(dy, dx); this.x += Math.cos(angle) * this.speed * dt; this.y += Math.sin(angle) * this.speed * dt; }
            if(this.mesh) this.mesh.position.set(this.x, 20, this.y);
        }
        dispose() { if(this.mesh) { scene.remove(this.mesh); this.mesh = null; } }
        draw(ctx) {}
    }

    class Particle {
        constructor(x, y, color, type='SMALL') {
            this.x=x; this.y=y;
            this.type = type;
            if (type === 'BURST') {
                this.life = 0.5; this.vx=(Math.random()-0.5)*300; this.vy=(Math.random()-0.5)*300; this.vz=(Math.random())*200; this.createMesh(color, 6);
            } else if (type === 'RISE') {
                this.life = 1.0; this.vx=(Math.random()-0.5)*50; this.vy=(Math.random()-0.5)*50; this.vz=100 + Math.random()*100; this.createMesh(color, 4);
            } else {
                this.life = 0.3; this.vx=(Math.random()-0.5)*100; this.vy=(Math.random()-0.5)*100; this.vz=50; this.createMesh(color, 3);
            }
        }
        createMesh(color, size) {
            const geo = new THREE.BoxGeometry(size, size, size);
            const mat = new THREE.MeshBasicMaterial({ color: getThreeColor(color) });
            this.mesh = new THREE.Mesh(geo, mat);
            this.mesh.position.set(this.x, 5, this.y);
            this.mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
            scene.add(this.mesh);
        }
        update(dt) {
            this.x+=this.vx*dt; this.y+=this.vy*dt;
            this.mesh.position.y += this.vz*dt;
            if (this.type === 'BURST') this.vz -= 500*dt;
            this.mesh.rotation.x += dt * 5;
            this.life-=dt;
            if(this.mesh) {
                this.mesh.position.set(this.x, this.mesh.position.y, this.y);
                this.mesh.scale.setScalar(this.life * 2);
                if(this.life <= 0) { scene.remove(this.mesh); this.mesh = null; }
            }
        }
        draw(ctx) {}
    }

    class ShockwaveRing {
        constructor(x, y, color) {
            this.x=x; this.y=y; this.life=0.5; this.maxLife=0.5;
            const geo = new THREE.RingGeometry(10, 20, 32); geo.rotateX(-Math.PI/2);
            const mat = new THREE.MeshBasicMaterial({ color: getThreeColor(color), transparent: true, opacity: 0.8, side: THREE.DoubleSide });
            this.mesh = new THREE.Mesh(geo, mat); this.mesh.position.set(x, 2, y); scene.add(this.mesh);
        }
        update(dt) {
            this.life-=dt;
            if(this.mesh) {
                let scale = 1 + (this.maxLife - this.life) * 15;
                this.mesh.scale.set(scale, scale, scale);
                this.mesh.material.opacity = this.life / this.maxLife;
                if(this.life <= 0) { scene.remove(this.mesh); this.mesh = null; }
            }
        }
        draw(ctx){}
    }

    function spawnMinions() { ['TOP', 'MID', 'BOT'].forEach(lane => { let bPos = getSpawnPoint('BLUE', lane); entities.push(new Unit(-1, bPos.x, bPos.y, 'BLUE', 'MINION', lane)); let rPos = getSpawnPoint('RED', lane); entities.push(new Unit(-1, rPos.x, rPos.y, 'RED', 'MINION', lane)); }); }
    function initUI() { const dock = document.getElementById('hero-dock'); entities.forEach(e => { if (e.type === 'HERO' && e.team === 'BLUE') { let btn = document.createElement('div'); btn.className = 'hero-btn'; btn.innerHTML = `<span class="hero-txt">${e.lane[0]}</span><div class="mp-fill" id="mp-${e.id}"></div>`; btn.onclick = () => e.castUltimate(); dock.appendChild(btn); e.uiBtn = btn; } }); }
    function updateUI() { entities.forEach(e => { if (e.uiBtn) { let fill = e.uiBtn.querySelector('.mp-fill'); if (fill) fill.style.height = `${e.mp}%`; if (e.mp >= 100) e.uiBtn.classList.add('ready'); else e.uiBtn.classList.remove('ready'); } }); let bBase = buildings.find(b=>b.type==='BASE'&&b.team==='BLUE'); let rBase = buildings.find(b=>b.type==='BASE'&&b.team==='RED'); if(bBase) document.getElementById('hp-blue').innerText = Math.floor(bBase.hp); if(rBase) document.getElementById('hp-red').innerText = Math.floor(rBase.hp); }
    function initGame() {
        width = window.innerWidth; height = window.innerHeight;
        MAP.BLUE_BASE = { x: 100, y: height - 100 }; MAP.RED_BASE = { x: width - 100, y: 100 }; MAP.LANES = { TOP_LEFT: { x: 100, y: 100 }, BOT_RIGHT: { x: width - 100, y: height - 100 } };

        init3D();

        buildings.push(new Building(MAP.BLUE_BASE.x, MAP.BLUE_BASE.y, 'BLUE', 'BASE', 'ALL'));
        buildings.push(new Building(MAP.RED_BASE.x, MAP.RED_BASE.y, 'RED', 'BASE', 'ALL'));

        let midX = (MAP.BLUE_BASE.x+MAP.RED_BASE.x)/2, midY = (MAP.BLUE_BASE.y+MAP.RED_BASE.y)/2;
        buildings.push(new Building(midX-120, midY+120, 'BLUE', 'TOWER', 'MID'));
        buildings.push(new Building(midX+120, midY-120, 'RED', 'TOWER', 'MID'));

        buildings.push(new Building(50, 300, 'BLUE', 'TOWER', 'TOP'));
        buildings.push(new Building(300, 50, 'RED', 'TOWER', 'TOP'));

        buildings.push(new Building(width-300, height-50, 'BLUE', 'TOWER', 'BOT'));
        buildings.push(new Building(width-50, height-300, 'RED', 'TOWER', 'BOT'));

        let lanes = ['TOP','TOP','MID','BOT','BOT']; let uid = 0; lanes.forEach(l => { let bPos = getSpawnPoint('BLUE', l); entities.push(new Unit(uid++, bPos.x, bPos.y, 'BLUE', 'HERO', l)); let rPos = getSpawnPoint('RED', l); entities.push(new Unit(uid++, rPos.x, rPos.y, 'RED', 'HERO', l)); }); initUI(); spawnMinions(); requestAnimationFrame(loop);
    }
    function loop(timestamp) { let rawDt = (timestamp - lastTime)/1000; lastTime = timestamp; if(rawDt > 0.1 || isNaN(rawDt)) rawDt = 0.016; let dt = IS_PAUSED ? 0 : rawDt * TIME_SCALE; if (!isGameOver) { if (!IS_PAUSED) { waveTimer -= dt; if(waveTimer <= 0) { spawnMinions(); waveTimer = SPAWN_INTERVAL; } document.getElementById('wave-timer').innerText = waveTimer.toFixed(1); resolveCollisions(); resolveCollisions(); } [...entities, ...buildings, ...projectiles, ...particles].forEach(e => e.update(dt)); if (!IS_PAUSED) { entities = entities.filter(e => e.type === 'HERO' || !e.dead); buildings = buildings.filter(b => !b.dead); projectiles = projectiles.filter(p => !p.hit); particles = particles.filter(p => p.life > 0); updateUI(); } } renderer.render(scene, camera); requestAnimationFrame(loop); }
    window.onresize = () => { width = window.innerWidth; height = window.innerHeight; let centerX = width/2, centerZ = height/2; let scale = Math.max(width, height) / 700; camera.aspect = width / height; camera.updateProjectionMatrix(); camera.position.set(centerX - 200 * scale, 450 * scale, centerZ + 600 * scale); camera.lookAt(centerX, 0, centerZ); renderer.setSize(width, height); }; initGame();

</script>
</body>
</html>
