<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Soul Hunters: Map Boundaries</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; font-family: 'Consolas', monospace; user-select: none; }
        #game-stage { position: relative; width: 100vw; height: 100vh; }
        canvas { display: block; width: 100%; height: 100%; }

        /* HUD */
        #ui-layer { position: absolute; top: 10px; width: 100%; pointer-events: none; z-index: 10; display: flex; justify-content: center; align-items: flex-start; }
        .score-board {
            background: rgba(0,0,0,0.7); color: white; padding: 10px 30px; border-radius: 5px;
            font-size: 20px; border: 1px solid #555; text-align: center;
        }
        .blue { color: #44aaff; } .red { color: #ff4444; }

        #debug-btn {
            position: absolute; top: 10px; right: 10px; pointer-events: auto;
            background: #333; color: #aaa; border: 1px solid #555; padding: 5px 10px;
            cursor: pointer; font-size: 12px; z-index: 20;
        }
        #debug-btn.active { background: #004400; color: #0f0; border-color: #0f0; }

        /* Ëã±ÈõÑÊìç‰ΩúÊ†è */
        #hero-dock {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 20; pointer-events: auto;
        }
        .hero-btn {
            width: 60px; height: 60px; border-radius: 50%; border: 3px solid #555;
            background: #333; color: white; font-weight: bold; font-size: 16px;
            display: flex; justify-content: center; align-items: center; flex-direction: column;
            cursor: pointer; transition: 0.2s; position: relative; overflow: hidden;
        }
        .hero-btn.ready { border-color: #ffd700; box-shadow: 0 0 15px #ffd700; background: #444; }
        .hero-btn:active { transform: scale(0.95); }
        .hero-btn.dead { filter: grayscale(100%); opacity: 0.5; cursor: not-allowed; }
        .hero-txt { z-index: 2; position: relative; text-shadow: 0 0 3px black; }
        .mp-fill { position: absolute; bottom: 0; left: 0; width: 100%; height: 0%; background: rgba(255, 215, 0, 0.5); transition: height 0.2s; pointer-events: none; z-index: 1; }

        /* ÁªìÁÆó */
        #settlement {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background:rgba(0,0,0,0.85); display:none; flex-direction:column;
            justify-content:center; align-items:center; z-index:100; color:white;
        }
        #settlement.show { display:flex; }
        h1 { font-size: 60px; margin-bottom: 20px; }
        button { padding: 10px 30px; font-size: 20px; cursor: pointer; background: #ffd700; border: none; font-weight: bold; border-radius: 5px; }
    </style>
</head>
<body>

<div id="game-stage">
    <canvas id="canvas"></canvas>

    <div id="ui-layer">
        <div class="score-board">
            <span class="blue">BLUE: <span id="hp-blue">...</span></span>
            VS
            <span class="red">RED: <span id="hp-red">...</span></span>
            <br>
            <span style="font-size:14px; color:#aaa">‰∏ã‰∏ÄÊ≥¢ÂÖµÁ∫ø: <span id="wave-timer">--</span>s</span>
        </div>
        <button id="debug-btn" onclick="toggleDebug()">üî≥ Debug Colliders</button>
    </div>

    <div id="hero-dock"></div>

    <div id="settlement">
        <h1 id="win-title">VICTORY</h1>
        <button onclick="location.reload()">RESTART</button>
    </div>
</div>

<script>
    /**
     * ÂºïÊìé V44: Âú∞ÂõæËæπÁïåÈôêÂà∂ (World Boundaries)
     */

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;

    const COLORS = { BLUE: '#44aaff', RED: '#ff4444', MINION_BLUE: '#88ccff', MINION_RED: '#ff8888', TOWER: '#ffffff' };

    const SPAWN_INTERVAL = 15.0;
    const RESPAWN_TIME = 20.0;

    let entities = [];
    let buildings = [];
    let projectiles = [];
    let particles = [];
    let floatingTexts = [];
    let waveTimer = SPAWN_INTERVAL;
    let isGameOver = false;
    let DEBUG_MODE = false;

    let MAP = { BLUE_BASE: {}, RED_BASE: {}, LANES: {} };

    function toggleDebug() {
        DEBUG_MODE = !DEBUG_MODE;
        const btn = document.getElementById('debug-btn');
        if(DEBUG_MODE) btn.classList.add('active');
        else btn.classList.remove('active');
    }

    function getSpawnPoint(team, lane) {
        let base = team === 'BLUE' ? MAP.BLUE_BASE : MAP.RED_BASE;
        let x = base.x;
        let y = base.y;
        let offset = 50;

        if (team === 'BLUE') {
            if (lane === 'TOP') y -= offset;
            else if (lane === 'BOT') x += offset;
            else { x += offset*0.7; y -= offset*0.7; }
        } else {
            if (lane === 'TOP') x -= offset;
            else if (lane === 'BOT') y += offset;
            else { x -= offset*0.7; y += offset*0.7; }
        }

        x += (Math.random() * 10 - 5);
        y += (Math.random() * 10 - 5);

        return { x, y };
    }

    function resolveCollisions() {
        // 1. Âçï‰Ωç‰∫íÊñ•
        for (let i = 0; i < entities.length; i++) {
            let u1 = entities[i];
            if (u1.dead || u1.state === 'RESPAWNING') continue;

            // üî• Êñ∞Â¢ûÔºöÂú∞ÂõæËæπÁïåÈôêÂà∂ (Á©∫Ê∞îÂ¢ô)
            if (u1.x < u1.radius) u1.x = u1.radius;
            if (u1.x > width - u1.radius) u1.x = width - u1.radius;
            if (u1.y < u1.radius) u1.y = u1.radius;
            if (u1.y > height - u1.radius) u1.y = height - u1.radius;

            for (let j = i + 1; j < entities.length; j++) {
                let u2 = entities[j];
                if (u2.dead || u2.state === 'RESPAWNING') continue;

                let dx = u1.x - u2.x;
                let dy = u1.y - u2.y;
                let distSq = dx*dx + dy*dy;
                let minSep = u1.radius + u2.radius;

                if (distSq < minSep * minSep && distSq > 0.01) {
                    let dist = Math.sqrt(distSq);
                    let overlap = minSep - dist;
                    let push = overlap * 0.5;
                    let nx = dx / dist; let ny = dy / dist;
                    u1.x += nx * push; u1.y += ny * push;
                    u2.x -= nx * push; u2.y -= ny * push;
                }
            }
        }

        // 2. Âçï‰Ωç‰∏éÂª∫Á≠ë
        entities.forEach(u => {
            if (u.dead || u.state === 'RESPAWNING') return;
            buildings.forEach(b => {
                if (b.dead) return;
                let dx = u.x - b.x; let dy = u.y - b.y;
                let distSq = dx*dx + dy*dy;
                let minSep = u.radius + b.radius;
                if (distSq < minSep * minSep) {
                    let dist = Math.sqrt(distSq);
                    if (dist < 0.1) { dist = 0.1; dx = 1; dy = 0; }
                    let overlap = minSep - dist;
                    let nx = dx / dist; let ny = dy / dist;
                    u.x += nx * overlap; u.y += ny * overlap;
                }
            });
        });
    }

    class Entity {
        constructor(x, y, team, radius) {
            this.x = x; this.y = y; this.team = team; this.radius = radius;
            this.hp = 100; this.maxHp = 100; this.dead = false;
        }
        takeDamage(amount, isCrit) {
            if(this.dead) return;
            this.hp -= amount;

            if (this.type === 'HERO' || isCrit || this.hp <= 0) {
                let color = isCrit ? '#ffd700' : '#fff';
                let size = isCrit ? 24 : 14;
                let txt = Math.floor(amount) + (isCrit?"!":"");
                floatingTexts.push(new FloatingText(this.x, this.y - this.radius - 10, txt, color, size));
            }
            if(this.hp <= 0) { this.hp = 0; this.die(); }
        }
        die() {
            this.dead = true;
            for(let i=0; i<8; i++) particles.push(new Particle(this.x, this.y, this.team === 'BLUE' ? COLORS.BLUE : COLORS.RED));
        }
    }

    class Building extends Entity {
        constructor(x, y, team, type) {
            super(x, y, team, type === 'BASE' ? 35 : 20);
            this.type = type;
            this.maxHp = type === 'BASE' ? 4000 : 1500;
            this.hp = this.maxHp;
            this.range = 160; this.atkDmg = 50; this.atkTimer = 0;
        }
        update(dt) {
            if (this.dead) return;
            this.atkTimer += dt;
            if (this.atkTimer > 1.2) {
                let target = findNearestTarget(this, this.range);
                if (target) {
                    projectiles.push(new Projectile(this.x, this.y, target, this.atkDmg, '#ffff00'));
                    this.atkTimer = 0;
                }
            }
        }
        draw(ctx) {
            if (this.dead) return;
            ctx.strokeStyle = this.team === 'BLUE' ? COLORS.BLUE : COLORS.RED;
            ctx.lineWidth = 3;
            if (this.type === 'BASE') {
                ctx.strokeRect(this.x - 30, this.y - 30, 60, 60);
            } else {
                ctx.beginPath(); ctx.moveTo(this.x, this.y-30); ctx.lineTo(this.x+30, this.y); ctx.lineTo(this.x, this.y+30); ctx.lineTo(this.x-30, this.y); ctx.closePath(); ctx.stroke();
            }
            let hpPct = this.hp / this.maxHp;
            let barY = this.y - 45;
            let barW = this.type === 'BASE' ? 60 : 40;
            let barX = this.x - barW / 2;
            ctx.fillStyle = '#333'; ctx.fillRect(barX, barY, barW, 6);
            ctx.fillStyle = '#0f0'; ctx.fillRect(barX, barY, barW * hpPct, 6);

            if (DEBUG_MODE) {
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = 'rgba(255, 255, 0, 0.2)';
                ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.stroke();
            }
        }
        die() {
            super.die();
            if (this.type === 'BASE') checkGameOver(this.team);
        }
    }

    class Unit extends Entity {
        constructor(id, x, y, team, type, lane) {
            super(x, y, team, type === 'HERO' ? 16 : 10);
            this.id = id; this.type = type; this.lane = lane;

            if (type === 'HERO') {
                this.maxHp = 1200; this.atk = 100; this.speed = 60; this.range = 130;
                this.mp = 0; this.maxMp = 100;
            } else {
                this.maxHp = 300; this.atk = 20; this.speed = 40; this.range = 45;
            }
            this.hp = this.maxHp;

            this.state = 'MOVE';
            this.respawnTimer = 0;
            this.target = null;
            this.atkTimer = 0;
            this.waypoints = this.getWaypoints(team, lane);
            this.wpIndex = 0;
            this.uiBtn = null;
            this.collider = { w: this.type === 'HERO' ? 40 : 20, h: this.type === 'HERO' ? 60 : 30 };
        }

        getWaypoints(team, lane) {
            let path = [];
            let enemyBase = team === 'BLUE' ? MAP.RED_BASE : MAP.BLUE_BASE;
            let off = (Math.random() - 0.5) * 40;
            if (lane === 'MID') { path.push({x: enemyBase.x, y: enemyBase.y}); }
            else if (lane === 'TOP') {
                let corner = MAP.LANES.TOP_LEFT;
                path.push({x: corner.x + off, y: corner.y + off});
                path.push({x: enemyBase.x, y: enemyBase.y});
            } else if (lane === 'BOT') {
                let corner = MAP.LANES.BOT_RIGHT;
                path.push({x: corner.x + off, y: corner.y + off});
                path.push({x: enemyBase.x, y: enemyBase.y});
            }
            return path;
        }

        getHitBox() {
            return { x: this.x - this.collider.w / 2, y: this.y - this.collider.h, w: this.collider.w, h: this.collider.h };
        }

        update(dt) {
            if (this.state === 'RESPAWNING') {
                this.respawnTimer -= dt;
                if (this.respawnTimer <= 0) this.respawn();
                return;
            }
            if (this.dead) return;

            if (this.type === 'HERO' && this.mp < 100) this.mp += dt * 8;
            if (this.type === 'HERO' && !this.isPlayerControlled() && this.mp >= 100 && this.target) {
                this.castUltimate();
            }

            if (!this.target || this.target.dead || this.target.state === 'RESPAWNING') {
                let searchRange = 350;
                if (this.type === 'MINION') searchRange = 180;
                this.target = findNearestTarget(this, searchRange);
            }

            if (this.target) {
                let dist = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                let range = this.range + this.target.radius;

                if (this.type === 'MINION' && dist > 250) {
                    this.target = null; this.state = 'MOVE'; return;
                }

                if (dist <= range) {
                    this.atkTimer += dt;
                    if (this.atkTimer > 1.5) {
                        let isCrit = Math.random() < 0.2;
                        let dmg = this.atk * (isCrit ? 2.0 : 1.0);
                        if (this.range > 50) projectiles.push(new Projectile(this.x, this.y, this.target, dmg, '#fff'));
                        else this.target.takeDamage(dmg, isCrit);
                        this.atkTimer = 0;
                        if(this.type === 'HERO') this.mp = Math.min(100, this.mp + 15);
                    }
                } else {
                    this.moveTowards(this.target.x, this.target.y, dt);
                }
            } else {
                if (this.lane !== 'MID' && this.wpIndex === 0 && this.waypoints.length > 1) {
                    let wp0 = this.waypoints[0];
                    let passed = false;
                    if (this.team === 'BLUE' && this.x > wp0.x + 80) passed = true;
                    if (this.team === 'RED'  && this.x < wp0.x - 80) passed = true;
                    if (passed) this.wpIndex = 1;
                }

                if (this.wpIndex < this.waypoints.length) {
                    let wp = this.waypoints[this.wpIndex];
                    if (Math.hypot(wp.x - this.x, wp.y - this.y) < 20) this.wpIndex++;
                    else this.moveTowards(wp.x, wp.y, dt);
                }
            }
        }

        moveTowards(tx, ty, dt) {
            let angle = Math.atan2(ty - this.y, tx - this.x);
            this.x += Math.cos(angle) * this.speed * dt;
            this.y += Math.sin(angle) * this.speed * dt;
        }

        castUltimate() {
            if (this.mp < 100 || this.dead) return;
            this.mp = 0;
            particles.push(new Shockwave(this.x, this.y, this.team === 'BLUE' ? COLORS.BLUE : COLORS.RED));
            floatingTexts.push(new FloatingText(this.x, this.y - 40, "ULT!", "#ffd700", 24));
            let targets = findAllTargets(this, 250);
            targets.forEach(t => t.takeDamage(200, true));
        }

        isPlayerControlled() { return this.team === 'BLUE'; }

        die() {
            if (this.type === 'HERO') {
                this.state = 'RESPAWNING';
                this.respawnTimer = RESPAWN_TIME;
                this.dead = true;
                if(this.uiBtn) this.uiBtn.classList.add('dead');
            } else {
                super.die();
            }
        }

        respawn() {
            this.dead = false; this.hp = this.maxHp; this.mp = 0;
            this.state = 'IDLE';

            this.lane = getBestLane(this.team);
            let spawnPos = getSpawnPoint(this.team, this.lane);

            this.x = spawnPos.x;
            this.y = spawnPos.y;

            this.target = null;
            this.waypoints = this.getWaypoints(this.team, this.lane);
            this.wpIndex = 0;

            for(let i=0; i<10; i++) particles.push(new Particle(this.x, this.y, '#fff'));

            if(this.uiBtn) {
                this.uiBtn.classList.remove('dead');
                let txtSpan = this.uiBtn.querySelector('.hero-txt');
                if(txtSpan) txtSpan.innerText = this.lane[0];
            }
        }

        draw(ctx) {
            if (this.state === 'RESPAWNING') {
                if (this.uiBtn) {
                    let txtSpan = this.uiBtn.querySelector('.hero-txt');
                    if(txtSpan) txtSpan.innerText = Math.ceil(this.respawnTimer);
                }
                return;
            }

            ctx.fillStyle = this.team === 'BLUE'
                ? (this.type==='HERO' ? COLORS.BLUE : COLORS.MINION_BLUE)
                : (this.type==='HERO' ? COLORS.RED : COLORS.MINION_RED);

            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.fill();

            if (this.type === 'HERO') {
                ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 2; ctx.stroke();
                if (this.mp >= 100) {
                    ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y, this.radius+5, 0, Math.PI*2); ctx.stroke();
                }
            }

            let hpW = this.radius * 2; let hpPct = this.hp / this.maxHp;
            ctx.fillStyle = '#000'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, hpW, 4);
            ctx.fillStyle = '#0f0'; ctx.fillRect(this.x - this.radius, this.y - this.radius - 8, hpW * hpPct, 4);

            if (DEBUG_MODE) {
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI*2); ctx.stroke();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.setLineDash([3, 3]);
                ctx.beginPath(); ctx.arc(this.x, this.y, this.range, 0, Math.PI*2); ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }

    function findNearestTarget(me, range) {
        let best = null; let minDist = range;
        let candidates = [...entities, ...buildings].filter(e => e.team !== me.team && !e.dead && e.state !== 'RESPAWNING');

        if (me.type === 'MINION') {
            candidates = candidates.filter(e => {
                if (e instanceof Building) return true;
                if (e instanceof Unit) return true;
                return false;
            });
        }

        candidates.forEach(t => {
            let d = Math.hypot(t.x - me.x, t.y - me.y);
            if (d < minDist) { minDist = d; best = t; }
        });
        return best;
    }

    function findAllTargets(me, range) {
        return [...entities, ...buildings].filter(e => e.team !== me.team && !e.dead && e.state !== 'RESPAWNING' && Math.hypot(e.x - me.x, e.y - me.y) <= range);
    }

    function getBestLane(myTeam) {
        let counts = { 'TOP': 0, 'MID': 0, 'BOT': 0 };
        entities.forEach(e => { if (!e.dead && e.state !== 'RESPAWNING' && e.lane) counts[e.lane]++; });
        let best = 'MID';
        if (counts.TOP > counts.MID && counts.TOP > counts.BOT) best = 'TOP';
        else if (counts.BOT > counts.MID && counts.BOT > counts.TOP) best = 'BOT';
        return best;
    }

    class Projectile {
        constructor(x, y, target, dmg, color) { this.x = x; this.y = y; this.target = target; this.dmg = dmg; this.color = color; this.speed = 400; this.hit = false; }
        update(dt) { if (this.hit) return; let dx = this.target.x - this.x; let dy = this.target.y - this.y; let dist = Math.hypot(dx, dy); if (dist < 10) { this.hit = true; this.target.takeDamage(this.dmg, false); } else { let angle = Math.atan2(dy, dx); this.x += Math.cos(angle) * this.speed * dt; this.y += Math.sin(angle) * this.speed * dt; } }
        draw(ctx) {
            ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
            if (DEBUG_MODE) { ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 1; ctx.beginPath(); ctx.arc(this.x, this.y, 6, 0, Math.PI*2); ctx.stroke(); }
        }
    }

    class FloatingText {
        constructor(x, y, text, color, size) { this.x = x; this.y = y; this.text = text; this.color = color; this.size = size; this.life = 0.8; }
        update(dt) { this.y -= 50 * dt; this.life -= dt; }
        draw(ctx) { ctx.globalAlpha = Math.max(0, this.life); ctx.fillStyle = this.color; ctx.font = `bold ${this.size}px Arial`; ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1; }
    }

    class Particle { constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.life=0.5; this.vx=(Math.random()-0.5)*150; this.vy=(Math.random()-0.5)*150; } update(dt) { this.x+=this.vx*dt; this.y+=this.vy*dt; this.life-=dt; } draw(ctx) { ctx.globalAlpha=this.life; ctx.fillStyle=this.color; ctx.beginPath(); ctx.arc(this.x,this.y,3,0,Math.PI*2); ctx.fill(); ctx.globalAlpha=1; } }
    class Shockwave { constructor(x, y, color) { this.x=x; this.y=y; this.color=color; this.r=10; this.life=0.5; } update(dt) { this.r += 200*dt; this.life-=dt; } draw(ctx) { ctx.globalAlpha = this.life; ctx.strokeStyle = this.color; ctx.lineWidth = 5; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; } }

    function checkGameOver(loserTeam) {
        if (isGameOver) return;
        isGameOver = true;
        let title = document.getElementById('win-title');
        document.getElementById('settlement').classList.add('show');
        if (loserTeam === 'RED') { title.innerText = "BLUE WINS!"; title.style.color = COLORS.BLUE; }
        else { title.innerText = "RED WINS!"; title.style.color = COLORS.RED; }
    }

    function spawnMinions() {
        ['TOP', 'MID', 'BOT'].forEach(lane => {
            // üî• ‰ΩøÁî®Âõ∫ÂÆöÂá∫ÁîüÁÇπ
            let bPos = getSpawnPoint('BLUE', lane);
            entities.push(new Unit(-1, bPos.x, bPos.y, 'BLUE', 'MINION', lane));

            let rPos = getSpawnPoint('RED', lane);
            entities.push(new Unit(-1, rPos.x, rPos.y, 'RED', 'MINION', lane));
        });
    }

    function initUI() {
        const dock = document.getElementById('hero-dock');
        entities.forEach(e => {
            if (e.type === 'HERO' && e.team === 'BLUE') {
                let btn = document.createElement('div');
                btn.className = 'hero-btn';
                btn.innerHTML = `<span class="hero-txt">${e.lane[0]}</span><div class="mp-fill" id="mp-${e.id}"></div>`;
                btn.onclick = () => e.castUltimate();
                dock.appendChild(btn);
                e.uiBtn = btn;
            }
        });
    }

    function updateUI() {
        entities.forEach(e => {
            if (e.uiBtn) {
                let fill = e.uiBtn.querySelector('.mp-fill');
                if (fill) fill.style.height = `${e.mp}%`;
                if (e.mp >= 100) e.uiBtn.classList.add('ready');
                else e.uiBtn.classList.remove('ready');
            }
        });

        let bBase = buildings.find(b=>b.type==='BASE'&&b.team==='BLUE');
        let rBase = buildings.find(b=>b.type==='BASE'&&b.team==='RED');
        if(bBase) document.getElementById('hp-blue').innerText = Math.floor(bBase.hp);
        if(rBase) document.getElementById('hp-red').innerText = Math.floor(rBase.hp);
    }

    function initGame() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
        MAP.BLUE_BASE = { x: 60, y: height - 60 };
        MAP.RED_BASE = { x: width - 60, y: 60 };
        MAP.LANES = { TOP_LEFT: { x: 60, y: 60 }, BOT_RIGHT: { x: width - 60, y: height - 60 } };

        buildings.push(new Building(MAP.BLUE_BASE.x, MAP.BLUE_BASE.y, 'BLUE', 'BASE'));
        buildings.push(new Building(MAP.RED_BASE.x, MAP.RED_BASE.y, 'RED', 'BASE'));
        let midX = (MAP.BLUE_BASE.x+MAP.RED_BASE.x)/2, midY = (MAP.BLUE_BASE.y+MAP.RED_BASE.y)/2;
        buildings.push(new Building(midX-80, midY+80, 'BLUE', 'TOWER'));
        buildings.push(new Building(midX+80, midY-80, 'RED', 'TOWER'));
        buildings.push(new Building(60, 200, 'BLUE', 'TOWER'));
        buildings.push(new Building(200, 60, 'RED', 'TOWER'));
        buildings.push(new Building(width-200, height-60, 'BLUE', 'TOWER'));
        buildings.push(new Building(width-60, height-200, 'RED', 'TOWER'));

        let lanes = ['TOP','TOP','MID','BOT','BOT'];
        let uid = 0;
        lanes.forEach(l => {
            // üî• ‰ΩøÁî®Âõ∫ÂÆöÂá∫ÁîüÁÇπ
            let bPos = getSpawnPoint('BLUE', l);
            entities.push(new Unit(uid++, bPos.x, bPos.y, 'BLUE', 'HERO', l));

            let rPos = getSpawnPoint('RED', l);
            entities.push(new Unit(uid++, rPos.x, rPos.y, 'RED', 'HERO', l));
        });

        initUI();
        spawnMinions();
        requestAnimationFrame(loop);
    }

    function loop(timestamp) {
        let dt = 0.016;
        ctx.fillStyle = '#222'; ctx.fillRect(0,0,width,height);

        ctx.strokeStyle = '#333'; ctx.lineWidth = 40; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(MAP.BLUE_BASE.x, MAP.BLUE_BASE.y); ctx.lineTo(MAP.RED_BASE.x, MAP.RED_BASE.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(MAP.BLUE_BASE.x, MAP.BLUE_BASE.y); ctx.lineTo(MAP.LANES.TOP_LEFT.x, MAP.LANES.TOP_LEFT.y); ctx.lineTo(MAP.RED_BASE.x, MAP.RED_BASE.y); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(MAP.BLUE_BASE.x, MAP.BLUE_BASE.y); ctx.lineTo(MAP.LANES.BOT_RIGHT.x, MAP.LANES.BOT_RIGHT.y); ctx.lineTo(MAP.RED_BASE.x, MAP.RED_BASE.y); ctx.stroke();

        if (DEBUG_MODE) {
            // ÁîªÂá∫Âú∞ÂõæËæπÁïåÁ∫¢Ê°Ü
            ctx.strokeStyle = '#ff0000'; ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);
        }

        if (!isGameOver) {
            waveTimer -= dt;
            if(waveTimer <= 0) { spawnMinions(); waveTimer = SPAWN_INTERVAL; }
            document.getElementById('wave-timer').innerText = waveTimer.toFixed(1);

            resolveCollisions();

            [...entities, ...buildings, ...projectiles, ...particles, ...floatingTexts].forEach(e => e.update(dt));

            entities = entities.filter(e => e.type === 'HERO' || !e.dead);
            buildings = buildings.filter(b => !b.dead);
            projectiles = projectiles.filter(p => !p.hit);
            particles = particles.filter(p => p.life > 0);
            floatingTexts = floatingTexts.filter(t => t.life > 0);
            updateUI();
        }

        [...buildings, ...entities, ...projectiles, ...particles, ...floatingTexts].forEach(e => e.draw(ctx));
        requestAnimationFrame(loop);
    }

    window.onresize = () => location.reload();
    initGame();

</script>
</body>
</html>