<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Soul Hunters: Final Battle</title>
    <style>
        body { margin: 0; background: #111; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        #game-stage { position: relative; width: 100vw; height: 100vh; background: #2b3e50; }
        canvas { display: block; image-rendering: pixelated; }

        /* UI æŒ‰é’® */
        #ui-layer { position: absolute; top: 20px; right: 20px; display: flex; gap: 10px; z-index: 10; }
        button { background: #444; color: white; border: 1px solid #666; padding: 8px 16px; cursor: pointer; border-radius: 4px; font-size: 14px; transition: 0.2s; }
        button:hover { background: #666; }
        button.active { background: #0f0; color: black; border-color: #0f0; }

        /* åŠ è½½æ–‡å­— */
        #loading { position: absolute; top: 50%; width: 100%; text-align: center; color: white; pointer-events: none; }

        /* ğŸ† ç»“ç®—é¢æ¿ */
        #settlement-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: opacity 0.5s; z-index: 100;
        }
        #settlement-modal.show { opacity: 1; pointer-events: auto; }

        .result-title { font-size: 80px; font-weight: bold; margin-bottom: 20px; letter-spacing: 5px; text-shadow: 0 0 20px rgba(0,0,0,0.5); }
        .win { color: #ffd700; text-shadow: 0 0 30px #ffd700; }
        .lose { color: #cc3333; text-shadow: 0 0 30px #cc3333; }

        .restart-btn {
            padding: 15px 50px; font-size: 24px; background: white; color: black; border: none;
            border-radius: 50px; cursor: pointer; font-weight: bold; box-shadow: 0 0 20px rgba(255,255,255,0.3);
        }
        .restart-btn:hover { transform: scale(1.05); }
    </style>
</head>
<body>

<div id="game-stage">
    <canvas id="canvas"></canvas>
    <div id="loading">èµ„æºåŠ è½½ä¸­...</div>
<!-- 
    <div id="ui-layer">
        <button id="btn-debug" onclick="toggleDebug()">ğŸ”³ Debug</button>
    </div> -->

    <div id="settlement-modal">
        <div id="result-text" class="result-title">VICTORY</div>
        <button class="restart-btn" onclick="location.reload()">PLAY AGAIN</button>
    </div>
</div>

<script>
    /**
     * å¼•æ“ V10: éšæœºä¼¤å®³ã€æš´å‡»é£˜å­—ã€ç»“ç®—é¢æ¿
     */

    let DEBUG_MODE = false;
    let IS_GAME_OVER = false;

    function toggleDebug() {
        DEBUG_MODE = !DEBUG_MODE;
        const btn = document.getElementById('btn-debug');
        if(DEBUG_MODE) btn.classList.add('active'); else btn.classList.remove('active');
    }

    // --- èµ„æºé…ç½® ---
    const ASSETS_CONFIG = {
        'WARRIOR': {
            collider: { width: 40, height: 60 }, anchorY: 50,
            actions: {
                'IDLE':   { src: 'warrior/Idle.png',      frames: 8, loop: true },
                'MOVE':   { src: 'warrior/Run.png',       frames: 8, loop: true },
                'ATTACK': { src: 'warrior/Attack1.png',   frames: 4, loop: true, damageFrame: 0.6 },
                'DEAD':   { src: 'warrior/Death.png',     frames: 6, loop: false },
                'HIT':    { src: 'warrior/Take Hit.png',  frames: 4, loop: false }
            }
        },
        'ARCHER': {
            collider: { width: 30, height: 70 }, anchorY: 25,
            actions: {
                'IDLE':   { src: 'archer/Idle.png',      frames: 10, loop: true },
                'MOVE':   { src: 'archer/Run.png',       frames: 8, loop: true },
                'ATTACK': { src: 'archer/Attack1.png',   frames: 6, loop: true, damageFrame: 0.6 },
                'DEAD':   { src: 'archer/Death.png',     frames: 10, loop: false },
                'HIT':    { src: 'archer/Take Hit.png',  frames: 3, loop: false }
            }
        },
        'FX': {
            'ARROW':  { src: 'archer/arrow/Move.png', frames: 2, speed: 0.1, collider: { width: 30, height: 10 } }
        }
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    let imageCache = {};
    let units = [];
    let projectiles = [];
    let floatingTexts = []; // ğŸŒŸ æ–°å¢ï¼šé£˜å­—åˆ—è¡¨
    let lastTime = 0;

    // --- å·¥å…·å‡½æ•° ---
    function checkRectCollision(rect1, rect2) {
        return (rect1.x < rect2.x + rect2.w && rect1.x + rect1.w > rect2.x &&
            rect1.y < rect2.y + rect2.h && rect1.y + rect1.h > rect2.y);
    }

    // ğŸŒŸ è®¡ç®—ä¼¤å®³ (å«æ³¢åŠ¨å’Œæš´å‡»)
    function calculateDamage(baseDmg) {
        // 1. ä¼¤å®³æ³¢åŠ¨ Â±10%
        let variance = baseDmg * 0.1;
        let finalDmg = baseDmg + (Math.random() * variance * 2 - variance);

        // 2. æš´å‡»åˆ¤å®š (20%å‡ ç‡)
        let isCrit = Math.random() < 0.2;
        if (isCrit) finalDmg *= 2;

        return { dmg: Math.floor(finalDmg), isCrit: isCrit };
    }

    // ğŸŒŸ é£˜å­—ç±»
    class FloatingText {
        constructor(x, y, text, color, size) {
            this.x = x; this.y = y;
            this.text = text; this.color = color; this.size = size;
            this.life = 1.0; // å­˜æ´»1ç§’
            this.vy = -50;   // å‘ä¸Šé£˜é€Ÿåº¦
        }
        update(dt) {
            this.y += this.vy * dt;
            this.life -= dt;
        }
        draw(ctx) {
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.font = `bold ${this.size}px Arial`;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.globalAlpha = 1.0;
        }
    }

    function loadAssets(callback) {
        let promises = [];
        for (let fx in ASSETS_CONFIG.FX) {
            let p = new Promise(resolve => {
                let img = new Image(); img.src = ASSETS_CONFIG.FX[fx].src;
                img.onload = () => { imageCache[`FX_${fx}`] = img; resolve(); };
                img.onerror = () => { resolve(); };
            }); promises.push(p);
        }
        for (let role in ASSETS_CONFIG) {
            if (role === 'FX') continue;
            for (let action in ASSETS_CONFIG[role].actions) {
                let src = ASSETS_CONFIG[role].actions[action].src;
                if (!imageCache[`${role}_${action}`]) {
                    let p = new Promise(resolve => {
                        let img = new Image(); img.src = src;
                        img.onload = () => { imageCache[`${role}_${action}`] = img; resolve(); };
                        img.onerror = () => { resolve(); };
                    }); promises.push(p);
                }
            }
        }
        Promise.all(promises).then(callback);
    }

    class Projectile {
        constructor(startX, startY, target, owner) {
            this.x = startX; this.y = startY;
            this.target = target; this.owner = owner;
            this.speed = 400; this.baseDmg = 15; this.hit = false;
            this.config = ASSETS_CONFIG.FX.ARROW;
            this.collider = this.config.collider;
            this.frameIndex = 0; this.animTimer = 0;
            this.totalFrames = this.config.frames || 1;
            this.animSpeed = this.config.speed || 0.1;
            let dx = target.x - startX;
            let dy = (target.getHitBox().center.y) - startY;
            this.angle = Math.atan2(dy, dx);
        }
        getHitBox() {
            return { x: this.x - this.collider.width/2, y: this.y - this.collider.height/2, w: this.collider.width, h: this.collider.height };
        }
        update(dt) {
            if (this.hit) return;
            this.animTimer += dt;
            if (this.animTimer >= this.animSpeed) {
                this.animTimer = 0; this.frameIndex = (this.frameIndex + 1) % this.totalFrames;
            }
            this.x += Math.cos(this.angle) * this.speed * dt;
            this.y += Math.sin(this.angle) * this.speed * dt;

            let arrowBox = this.getHitBox();
            let targetBox = this.target.getHitBox().rect;
            if (checkRectCollision(arrowBox, targetBox) && this.target.state !== 'DEAD') {
                this.hit = true;
                // ğŸŒŸ é€ æˆéšæœºä¼¤å®³
                let res = calculateDamage(this.baseDmg);
                this.target.takeDamage(res.dmg, res.isCrit);
            }
        }
        draw(ctx) {
            let img = imageCache['FX_ARROW'];
            ctx.save(); ctx.translate(this.x, this.y); ctx.rotate(this.angle);
            if (img) {
                let frameW = img.width / this.totalFrames; let frameH = img.height;
                try { ctx.drawImage(img, this.frameIndex * frameW, 0, frameW, frameH, -30, -10, 60, 20); } catch(e) {}
            }
            ctx.restore();
            if (DEBUG_MODE) {
                let box = this.getHitBox();
                ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 1; ctx.strokeRect(box.x, box.y, box.w, box.h);
            }
        }
    }

    class SpriteAnimator {
        constructor(unit, roleType) {
            this.unit = unit; this.roleType = roleType;
            this.currentAction = 'IDLE'; this.timer = 0; this.frameIndex = 0; this.defaultSpeed = 0.1;
        }
        update(dt) {
            let desired = this.unit.state;
            if (desired !== this.currentAction) {
                this.currentAction = desired; this.frameIndex = 0; this.timer = 0;
            }
            let config = ASSETS_CONFIG[this.roleType].actions[this.currentAction];
            if (!config) return;
            this.timer += dt;
            if (this.timer >= this.defaultSpeed) {
                this.timer = 0;
                if (config.loop === false) {
                    if (this.frameIndex < config.frames - 1) this.frameIndex++;
                } else {
                    this.frameIndex = (this.frameIndex + 1) % config.frames;
                }
            }
        }
        draw(ctx, x, y, isLeft) {
            let key = `${this.roleType}_${this.currentAction}`;
            let img = imageCache[key];
            let roleCfg = ASSETS_CONFIG[this.roleType];
            let actionCfg = roleCfg.actions[this.currentAction];
            if (!img || !actionCfg) return false;
            let frameW = img.width / actionCfg.frames; let frameH = img.height; let scale = 2.0;
            let anchorY = (roleCfg.anchorY !== undefined) ? roleCfg.anchorY : 25;
            let baseOffsetX = -frameW * scale / 2; let baseOffsetY = -frameH * scale / 2 - anchorY;
            let fix = actionCfg.offsetFix || [0, 0];
            let finalOffsetX = baseOffsetX + (isLeft ? -fix[0]*scale : fix[0]*scale);
            let finalOffsetY = baseOffsetY + fix[1]*scale;
            ctx.save(); ctx.translate(x, y); if (isLeft) ctx.scale(-1, 1);
            ctx.drawImage(img, this.frameIndex * frameW, 0, frameW, frameH, finalOffsetX, finalOffsetY, frameW*scale, frameH*scale);
            ctx.restore();
            return true;
        }
    }

    class Unit {
        constructor(isPlayer, roleType, x, y) {
            this.isPlayer = isPlayer; this.roleType = roleType;
            this.x = x; this.y = y; this.hp = 100; this.state = 'IDLE';
            this.target = null;
            let cfg = ASSETS_CONFIG[roleType];
            this.collider = cfg.collider || {width: 40, height: 80};
            if (roleType === 'ARCHER') { this.range = 300; this.speed = 50; this.baseDmg = 15; }
            else { this.range = 60; this.speed = 80; this.baseDmg = 25; }
            this.atkTimer = 0; this.hitTimer = 0;
            this.animator = new SpriteAnimator(this, roleType);
        }
        getHitBox() {
            let w = this.collider.width; let h = this.collider.height;
            return { rect: { x: this.x - w/2, y: this.y - h, w: w, h: h }, center: { x: this.x, y: this.y - h/2 } };
        }
        update(dt) {
            this.animator.update(dt);
            if (this.state === 'DEAD') return;
            if (this.state === 'HIT') {
                this.hitTimer -= dt; if (this.hitTimer <= 0) this.state = 'IDLE'; return;
            }
            if (!this.target || this.target.hp <= 0) {
                this.target = findTarget(this); if (!this.target) { this.state = 'IDLE'; return; }
            }
            let dist = Math.abs(this.target.x - this.x);
            if (dist <= this.range) {
                this.state = 'ATTACK';
                this.atkTimer += dt;
                let animConf = ASSETS_CONFIG[this.roleType].actions['ATTACK'];
                let triggerTime = animConf ? animConf.damageFrame : 0.5;
                if (this.atkTimer > triggerTime) {
                    // ğŸŒŸ æ”»å‡»é€»è¾‘ï¼šå¸¦æš´å‡»çš„éšæœºä¼¤å®³
                    if (this.roleType === 'ARCHER') {
                        projectiles.push(new Projectile(this.x, this.y - 40, this.target, this));
                    } else {
                        let res = calculateDamage(this.baseDmg);
                        this.target.takeDamage(res.dmg, res.isCrit);
                    }
                    this.atkTimer = -0.5;
                }
            } else {
                this.state = 'MOVE';
                let dir = this.target.x > this.x ? 1 : -1;
                this.x += dir * this.speed * dt;
            }
        }

        // ğŸŒŸ å—å‡»é€»è¾‘ï¼šå¤„ç†é£˜å­—å’Œæ­»äº¡
        takeDamage(dmg, isCrit) {
            if (this.state === 'DEAD') return;
            this.hp -= dmg;
            this.state = 'HIT';
            this.hitTimer = 0.3;

            // ç”Ÿæˆé£˜å­—
            let color = isCrit ? '#ffd700' : '#ffffff';
            let size = isCrit ? 30 : 18;
            let text = isCrit ? `Crit ${dmg}!` : `${dmg}`;
            floatingTexts.push(new FloatingText(this.x, this.y - 80, text, color, size));

            if (this.hp <= 0) {
                this.hp = 0;
                this.state = 'DEAD';
                checkGameOver(); // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
            }
        }

        draw(ctx) {
            ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.beginPath(); ctx.ellipse(this.x, this.y, 15, 6, 0, 0, Math.PI*2); ctx.fill();
            let isLeft = !this.isPlayer;
            let drawn = this.animator.draw(ctx, this.x, this.y, isLeft);
            if (!drawn) { ctx.fillStyle = this.isPlayer?'blue':'red'; ctx.fillRect(this.x-10, this.y-40, 20, 40); }
            if (this.state !== 'DEAD') {
                ctx.fillStyle = '#333'; ctx.fillRect(this.x - 15, this.y - 85, 30, 4);
                ctx.fillStyle = this.isPlayer ? '#0f0' : '#f00'; ctx.fillRect(this.x - 15, this.y - 85, 30 * (this.hp/100), 4);
            }
            if (DEBUG_MODE && this.state !== 'DEAD') {
                let box = this.getHitBox().rect;
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 1; ctx.strokeRect(box.x, box.y, box.w, box.h);
            }
        }
    }

    function findTarget(me) {
        let targets = units.filter(u => u.isPlayer !== me.isPlayer && u.hp > 0);
        if (targets.length === 0) return null;
        return targets.sort((a,b) => Math.abs(a.x - me.x) - Math.abs(b.x - me.x))[0];
    }

    // ğŸŒŸ æ£€æŸ¥æ¸¸æˆç»“æŸ
    function checkGameOver() {
        if (IS_GAME_OVER) return;

        let playersAlive = units.filter(u => u.isPlayer && u.hp > 0).length;
        let enemiesAlive = units.filter(u => !u.isPlayer && u.hp > 0).length;

        if (playersAlive === 0 || enemiesAlive === 0) {
            IS_GAME_OVER = true;
            let isWin = playersAlive > 0;

            // ç¨å¾®å»¶è¿Ÿå¼¹å‡ºç»“ç®—ï¼Œè®©ç©å®¶çœ‹åˆ°æœ€åä¸€æ¬¡æ”»å‡»
            setTimeout(() => {
                showSettlement(isWin);
            }, 1000);
        }
    }

    // ğŸŒŸ æ˜¾ç¤ºç»“ç®—é¢æ¿
    function showSettlement(isWin) {
        const modal = document.getElementById('settlement-modal');
        const text = document.getElementById('result-text');

        modal.classList.add('show');
        if (isWin) {
            text.innerText = "VICTORY";
            text.className = "result-title win";
        } else {
            text.innerText = "DEFEAT";
            text.className = "result-title lose";
        }
    }

    function resize() { canvas.width = window.innerWidth; canvas.height = window.innerHeight; width = canvas.width; height = canvas.height; }
    window.onresize = resize;

    function loop(timestamp) {
        let dt = (timestamp - lastTime) / 1000; lastTime = timestamp; if (dt > 0.1) dt = 0.1;
        ctx.clearRect(0, 0, width, height); ctx.fillStyle = '#1e272e'; ctx.fillRect(0, height/2, width, height/2);

        // æ›´æ–°å’Œç»˜åˆ¶æŠ•å°„ç‰©
        for (let i = projectiles.length - 1; i >= 0; i--) {
            let p = projectiles[i]; p.update(dt); p.draw(ctx);
            if (p.hit) projectiles.splice(i, 1);
        }

        // æ›´æ–°å•ä½
        units.sort((a,b) => a.y - b.y);
        units.forEach(u => { u.update(dt); u.draw(ctx); });

        // ğŸŒŸ æ›´æ–°å’Œç»˜åˆ¶é£˜å­—
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            let ft = floatingTexts[i];
            ft.update(dt);
            ft.draw(ctx);
            if (ft.life <= 0) floatingTexts.splice(i, 1);
        }

        requestAnimationFrame(loop);
    }

    resize();
    loadAssets(() => {
        document.getElementById('loading').style.display = 'none';

        // æ··ç¼–å°é˜Ÿï¼š2æˆ˜å£« + 2å°„æ‰‹
        units.push(new Unit(true, 'WARRIOR', 250, height/2 + 30));
        units.push(new Unit(true, 'WARRIOR', 250, height/2 + 60));
        units.push(new Unit(true, 'ARCHER',  150, height/2 + 10));
        units.push(new Unit(true, 'ARCHER',  150, height/2 + 80));

        units.push(new Unit(false, 'WARRIOR', width - 250, height/2 + 30));
        units.push(new Unit(false, 'WARRIOR', width - 250, height/2 + 60));
        units.push(new Unit(false, 'ARCHER',  width - 150, height/2 + 10));
        units.push(new Unit(false, 'ARCHER',  width - 150, height/2 + 80));

        requestAnimationFrame(loop);
    });

</script>
</body>
</html>
